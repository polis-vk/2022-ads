# Отчет по бенчмаркам - Почернин Владислав

## Формулировка задания

- Написать **JMH** бенчмарки и сравнить время работы **следующих алгоритмов**:
  - Обычная сортировка вставками.
  - "Улучшенная" сортировка вставками.
  - Сортировка слиянием.
  - Быстрая сортировка.
  - Пирамидальная сортировка.
- Посмотреть на время работы алгоритмов на различных по длине **входных массивах**:
  - 100
  - 1_000
  - 10_000
  - 100_000
  - 1 000_000
- Результаты отобразить в отчете в формате *Markdown*, где:
  - Вставить (в виде *Markdown* кода) таблички с результатами бенчмарков.
  - Отметить, какие алгоритмы на каких размерах массивов ведут себя лучше других.

## Теория

- **JMH** - Java Microbenchmark Harness - фреймворк для написания бенчмарков на языке Java.
- Казалось бы, можно просто считать время до и после работы алгоритма, но это будет **неправильно**.
  - JVM производит множество оптимизаций кода и данные, которые мы получим, могут быть *недостоверными*.
  - Кроме того, **JMH** предоставляет множество удобных настроек.
  - Наконец, **JMH** позволяет "прогреть" тестируемую функцию, несколько раз запустив её перед тестированием для применения всех оптимизаций JVM.

### Настройка JMH

- Метод, который будет тестироваться нужно пометить аннотацией `@Benchmark`.
- Чтобы код, который мы тестируем не был выброшен JVM, его нужно применить в некий `Blackhole`
- Приведем пример тестирования:
```java  
@Benchmark  
public void measureFibTailRec(Blackhole bh) {  
    bh.consume(Fib.tailRecFib(dataLength));  
}  
```  

- Также можно удобно задать параметр аннотацией `@Param` (например, чтобы выполнилось несколько бенчмарков для нескольких значений):
```java  
@Param({"45", "60"})  
private int datalength;  
```  

- Перед каждым прогоном бенчмарка будет выполняться инициализация из метода, помеченного аннотацией `@Setup`:
```java  
@Setup(value = Level.Invocation)  
public void setUpInvocation() {  
        array = IntStream.generate(() -> ThreadLocalRandom.current().nextInt()).limit(dataLength).boxed().toArray(Integer[]::new)  
}  
```  

- Наконец, чтобы запустить тесты, нужно создать объект типа `Options` и запустить его:
```java  
Options opt = new OptionsBuilder()  
        .include(InsertionSortBench.class.getSimpleName())  
        .forks(1)  
        .jvmArgs("-Xms1G", "-Xmx1G")  
        .warmupIterations(3)  
        .measurementIterations(3)  
        .build();  
  
        new Runner(opt).run();  
```  
- Здесь мы можем увидеть следующие настройки:
  - `forks(1)` - вызов каждого теста в отдельном процессе.
  - `warmupIterations(3)` - три итерации "прогрева" функции перед тестированием.
  - `measurementIterations(3)` - каждый случай будет тестироваться по 3 раза и вернется среднее арифметическое.

## Результаты тестирования

- Каждый вышеупомянутый алгоритм сортировки был протестирован на различных размерах массива с помощью фреймворка **JMH**.
- Единственным исключением стал алгоритм `InsertionSort`, который не тестировался на размере массива в `1 000 000` элементов из-за крайне высокого времени тестирования. Однако, это не мешает анализу и сравнению скоростей наших сортировок, поскольку на столь больших данных он, очевидно, является аутсайдером.

- Все результаты были получены в отдельных процессах.
- Перед каждым тестом 3 раза выполнялся "прогрев".
- Каждый тест прогонялся 3 раза и считалось среднее арифметическое.

### 100 элементов

| Сортировка           | Время (ms) | Ошибка (ms) |
|----------------------|------------|-------------|
| Вставками            |   0.005         |  ±    0.001            |
| Вставками улучшенная |   0.006         |   ±    0.001          |
| Слиянием             |   0.006         |     ±    0.001        |
| Быстрая              |    0.006        |        ±    0.001     |
| Пирамидальная        |    0.006        |±    0.001             |

### 1_000 элементов

| Сортировка           | Время (ms) | Ошибка (ms) |
|----------------------|------------|-------------|
| Вставками            |  0.335          |   ±    0.133          |
| Вставками улучшенная |    0.089        |±    0.001              |
| Слиянием             |   0.094         |     ±    0.005        |
| Быстрая              |    0.094        |      ±    0.004       |
| Пирамидальная        |  0.089          |    ±    0.001         |

### 10_000 элементов

| Сортировка           | Время (ms) | Ошибка (ms) |
|----------------------|------------|-------------|
| Вставками            |     30.630        | ±    3.341            |
| Вставками улучшенная |    2.730        | ±    0.007            |
| Слиянием             |    1.223        |  ±    0.053           |
| Быстрая              |      1.297      |   ±    0.301          |
| Пирамидальная        |        1.757    |   ±    0.026          |

### 100_000 элементов

| Сортировка           | Время (ms) | Ошибка (ms) |
|----------------------|------------|-------------|
| Вставками            |   9237.681         |  ± 6205.638           |
| Вставками улучшенная |   306.629         |   ±  144.440          |
| Слиянием             |    16.111        |  ±    1.976            |
| Быстрая              |     15.273       |    ±    9.135         |
| Пирамидальная        |    27.888        |  ±    0.181           |

### 1_000_000 элементов

| Сортировка           | Время (ms) | Ошибка (ms) |
|----------------------|------------|-------------|
| Вставками            |       -     |        -     |
| Вставками улучшенная |  67032.265          | ± 224430.151            |
| Слиянием             |   401.126         |  ±    126.927          |
| Быстрая              |     328.206       |    ±    276.535         |
| Пирамидальная        | 870.711           |   ±    292.309          |

## Выводы

Согласно полученным результатам, мы можем сделать следующие заключения:

- На малых размерах массива (примерно до 100 элементов), сортировка **вставками** может отработать быстрее более сложных сортировок. Далее, с ростом количества элементов, она начинает проигрывать всем остальным сортировкам.
- **Улучшенная сортировка вставками** хоть и показывает лучший (среди прочих сортировок) результат на `1_000` элементов, затем ухуждшает свои результаты, проигрывая всем (кроме, конечно, сортировки вставками).
- Из оставшихся трех сортировок можно выделить **пирамидальную**, как самую медленную. Хоть она и работает почти также, как и остальные (быстрая и слиянием), с ростом количества элементов все больше становится виден разрвы между ними. Однако, на массиве с `1_000` элементами она обгоняет две вышеупомянутые сортировки.
- На протяжении всех тестов, **быстрая сортировка** и **сортировка слиянием** идут почти одинакого и, хотя на `10_000` элементах мы видим небольшую победу сортировки слиянием, дальше быстрая сортировка начинает немного, но выигрывать.
  - Здесь также стоит отметить то, что разница между этими двумя сортировками является меньше погрешности вычисления времени, соответственно, мы не можем достоверно сказать, кто лучше.

Итак, проанализировав приведенные сортировки, можно назвать двух победителей: **быструю сортировку* и **сортировку слиянием**. В случае больших объемов данных оптимально использовать одну из них. Однако, на малых объемах данных (примерно `100` элементов), более быстрой может оказаться **сортировка вставками**.
